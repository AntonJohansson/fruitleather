```
type Set(x): "\mathbb{${0}}";
var R: Set;
var N: Set;
type Inf(x): "\infty";
var inf: Inf;
type Null(x): "\varnothing";
var null: Null;

// Set operations
op subset[=](M: Set, N: Set) -> Set: "\subset";
op subseteq[=](M: Set, N: Set) -> Set: "\subseteq";
op nsubset[=](M: Set, N: Set) -> Set: "\not\subset";
op nsubseteq[=](M: Set, N: Set) -> Set: "\not\subseteq";
op supset[=](M: Set, N: Set) -> Set: "\supset";
op supseteq[=](M: Set, N: Set) -> Set: "\supseteq";
op nsupset[=](M: Set, N: Set) -> Set: "\not\supset";
op nsupseteq[=](M: Set, N: Set) -> Set: "\not\supseteq";

op u[+](M: Set, N: Set) -> Set: "\cup";
op n[*](M: Set, N: Set) -> Set: "\cap";

op take[/](M: Set, N: Set) -> Set: "\backslash";
op definedto[=](M: Unknown, N: Unknown) -> Unknown: ":=";
op definefunc[=](M: Unknown, N: Unknown) -> Unknown: ":";

func P(X: Set) ->Set: "\mathcal{P}(${0})";
func Union(S: Set, a: Unknown, b: Unknown) -> Set: "\bigcup_{i=${1}}^{${2}} ${0}";
func Isect(S: Set, a: Unknown) -> Set: "\bigcap_{${1}} ${0}";
func set(V: Vector) -> Set: "${0}";

// Intervals
func Icc(a: Number, b: Number) -> Set: "[${0},${1}]";
func Ioo(a: Number, b: Number) -> Set: "(${0},${1})";
func Ico(a: Number, b: Number) -> Set: "[${0},${1})";
func Ioc(a: Number, b: Number) -> Set: "(${0},${1}]";

func sum(f: Unknown, a: Unknown, b: Unknown) -> Unknown: "\sum_{${1}}^{${2}} ${0}";

func forall(a: Unknown) -> Unknown: "\forall ${0}";

// TODO: Remove
op noteq[=](a: Unknown, b: Unknown) -> Unknown: "\neq";
```

# Measure Theory

## Motivation

Consider sets of numbers `S`, can we somehow assign a general notion of area/volume/length to `S`?

For closed intervals of the real line `[a,b] subset R` the notion of length is straightforward, simply take `mu = b-a`; but what about more complicated subsets (TODO: example)?

## Subsets

```
var X: Set;
```

In the abstract setting we want to provide a notion of length/area/volume to general subsets of a given set `X`. Or in other terms consider maps from
```
mu definefunc P(X) -> R;
```
where `P(X)` is the powerset of `X`.

In general, providing such a function that covers every subset is not feasible, and we instead restrict ourselves to covering measureable subsets.

// TODO: Type in title
@def(sa) sigma-algebra
{
Given a set `X`, a subset `A subseteq P(X)` is called a `sigma`-algebra if 1. `null in A` and `X in A`; 2. `S subset A ==> S^c definedto X take S subset A`; 3. `S_i subset A, i in N ==> Union(S_i,1,inf) subset A`.
}

@thm(saisect)
{
    If `A_i` are all `sigma`-algebras on `X`, with `i in I` (index set), then `Isect(A_i, i in I)` is also a `sigma`-algebra on `X`.
}

@pf(saisect)
{
Per definition `null,X in A_i ==> null,X in Isect(A_i, i in I)`, so condition 1. is satisfied, and for a subset `S subset Isect(A_i, i in I)` then `S subset A_j` for any `j in I`, therefore `S^c subset A_j ==> S^c subset Isect(A_i, i in I)`, and condition 2. holds. Likewise for subsets `S_j subset Isect(A_i,i in I), j in N`, then `Union(S_j, j, inf) subset A_k` for some `k in I` and `Union(S_j, j, inf) subset Isect(A_i, i in I)`, and condition 3. holds.
}

ref(thm:saisect) is useful in constructing `sigma`-algebras with certain properties, as the you can construct a `sigma`-algebra for each property and then simply take the union.

@def(gensa) sigma algebra construction
{
For `sigma`-algebra `S subseteq P(X)` a family of subsets `M subseteq P(X)`, there exists a smallest `sigma`-algebra that contains `M` given by
```
sigma(M) definedto Isect(A, S supseteq A supseteq M);
```
}

Example

// TODO: Add way to clear varialbes, using X here is not allowed in
// X = {a,b,c,d};
Given `X = set({a,b,c,d})` and `M = set({{a},{b}})`. Note `M` is not a `sigma`-algebra on `X` as 1. `X,null nsubset M`; 2. `set({a})^c,set({b})^c nsubset M`; 3. `set({a}) u set({b}) nsubset M`. But we can construct `sigma(M)` by adding these elements
```
sigma(M) = M u set({{a,b}}) u set({null,X}) u set({{b,c,d},{a,c,d},{c,d}});
```

Construction of `sigma(M)` is however much more complicated if `M` is infinite. 

@def(borelsa) Borel sigma algebra
{
Given a set `X` and a topological space `[X,tau]`, the `sigma`-algebra formed by
```
B(X) definedto sigma(tau);
```
is called the Borel `sigma`-algebra and is generated by all open sets of `X`.
}

@def(measure) Measure
{
A set `X` along with a fixed `sigma`-algebra `A` is said to measurable space, and a map
```
mu definefunc A -> Icc(0,inf);
```
with `Icc(0,inf) definedto Ico(0,inf) u set({inf})` satisfying
```
mu(null) = 0;
mu(Union(A_i,i=1,inf)) = sum(mu(A_i),i=1,inf), A_i n A_j = null, i noteq j, forall(A_i in A);
```
is called a measure. The tuple `[X, A, mu]` is called a measure space.
}

Example (works on all sets)

Given a set `X`, `A = P(X)`, we can define a counting measure by `mu(S) definedto ord(S)` if `S` has finitely many items, or `mu(S) definedto inf` otherwise.

Given a set `X`, `A = P(X)`, we can define a diract measure by `delta_p (S) definedto 1` if `p in S`, or `mu(S) definedto 0` otherwise.

Goal is to find a measure for `R^n`, such that
```
mu(Icc(0,1)^n) = 1;
mu(x + A) = mu(A), forall(x in R^n);
```
